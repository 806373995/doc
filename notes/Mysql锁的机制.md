# Mysql锁机制总结以及应用场景

*以下都已innoDB为例*

## 锁粒度

- **行锁**：innoDB支持行锁，但是InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，所以要使用行锁，必须让索引不失效，否则会升级为表锁。目前的加锁方式为**自动加锁**，自动加锁方式为，使用update、delete、insert、for update、lock in share mode 都会自动加锁（加锁都是按照事务一个整的事务来加锁），如果使用行锁，有可能会造成死锁的情况，所以在写业务时需要注意这点。
- **表锁：**顾名思义表锁，将整张表锁住，如果使用锁表可能会导致性能低下。
- **间隙锁：**按照索引的范围查询加锁



## 共享锁与排他锁以及快照读

- **共享锁：**又称之为读锁，简称S锁。使用方法在mysql中select语句中加**lock in share mode** ，在被加共享锁的数据不能使用排他锁读数据，相当于不能修改该数据。共享锁主要是为了**支持并发的读取数据**而出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免”不可重读”（同一事务两次读取的内容不同）的问题的出现。另外**写锁的的优先级比读锁的优先级高**（可以理解为有写锁优先进入写锁的线程）。
- **排他锁：**又称之为写锁，简称X锁。使用方法在mysql update,insert,delete会自动加排他锁，如果在select 中需要，在语句中加入for update。在被加排他锁的数据，及**不能使用共享锁也不能使用排他锁的数据**。写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。
- **快照读：**一般我没直接使用的select语句都为快照度，当使用了快照读，在当前事务中，相当于已经生成的一张快照，每次读都会按照**快照里面的数据读取**，至于后面提交的事务，不会影响快照读的结果。

应用场景：

![业务锁](.\image\业务锁.png)

A表：作为数据表。

B表：作为状态表。

A线程：首先需要判断B表中的状态，然后根据状态来判断A表是否能新增，修改，删除。

B线程：需要获取A表中的累计值，然后根据累计值，来判断是否能够修改B表。

解释：A线程，首先需要保证B表的状态不能变，所以加读锁，保证不修改，然后操作A表

B线程，在指定的b表加入写锁,防止A线程修改响应的数据。可以这样理解，

1. 先走B线程。

2. 首先锁住B表对应的数据。

3. 然后如果在B线程调用的过程中，A线程启动。

4. 那么A线程就会卡住，一整等到B线程走到修改状态一步，

5. A线程才能根据B更新的最新的线程来执行。

## MVCC和快照读

参照文章：https://www.jianshu.com/p/20fa5703bd3e

视频：https://www.bilibili.com/video/BV1YJ411J7vb

在加锁读中，能够保证读到数据最新的版本，但是不可能所有的数据都采用加锁读，所以就快照读的模式。理论上实现快照有两种方式

1. 每个快照生成一套数据，每个快照读取自己的数据。如果是按照这种模式，那么数据量会非常大，应为当你有多个事务，那么就会创建这些事务的单独的数据。
2. 基于的数据，给快照生成他能看到那些数据，看不到那些数据的一个标记（MVCC中的read-view）。如果按照这种模式，那么第一种方式的数据量问题大就解决了。

多版本并发控制（MVCC）就是按照上述第二条来设计的，下面是详细的理解。

### InnoDB在每行数据都增加三个隐藏字段

1. 一个 6字节的 DB_TRX_ID 字段 即:通常在其他文章中看到的 事务id

2. 一个7字节的 DB_ROLL_PTR 字段 即:通常范围以回滚指针

3. 一个 6字节的 DB_ROW_ID 字段, 该字段在当前事务自增,主要是确定当前数据id (本文章中不涉及该字段)

例如

| id   | name | DB_TRX_ID | DB_ROLL_PTR | DB_ROW_ID |
| ---- | ---- | --------- | ----------- | --------- |
| 1    | 张三 | 100       | xxx         | xx        |

## undo log

undo log：提供回滚操作的日志，它其中包含了数据所有的历史日志，可以理解为undo log中包含历史的数据，如下图

![undolog](.\image\undolog.png)

### read view

在事务开启的一条查询，会生成相应的read view存储的内容包含当前所有 **未提交的事务id** + **已提交事务id** 的最大值组成。

![readview](.\image\readview.png)

### 数据可视性原则

首先, mysql 把数据分为三种状态,已提交事务，未提交与已提交事务，未开启事务，那么这3种状态的区分规则为使用两个节点的id区分min_id 和max_id。所以将read view的抽象图就是下表

![微信截图_20210920154115](.\image\微信截图_20210920154115.png)

按照上上图中，取值的话 min_id应该取，未提交id中，最小的id值也就是100。max_id取值就应该取当前事务最大的id也就是300。

那么具体的取值是如何取值的呢?

1. 如果被访问版本的trx_id属性值小于min_id，所以该版本可以被当前事务访问。

2. 如果被访问版本的trx_id属性值大于max_id，所以该版本可以被当前事务访问。

4. 如果被访问版本的trx_id属性值在min_id和max_id之间，那就需要判断一下trx_id属性值是不是在**未提交的事务id**列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

## 事务隔离与MVCC

在事务中仅有 已提交读 和 可重复读 支持MVCC机制

在已提交读中，每次（一个事务中）做select 都会生成快照(Read view)，所以每次都会查询到最新的已提交的事务

在可重复读中，每次（一个事务中）做select 只会有第一次select会生成快照，后面的select都会使用第一次的read view来查询，所以每次每次的查询都是可重复的查询。

未提交读，之所以不需要MVCC是因为每次读都会读最新的数据（包含未提交的数据），所以根本用不到MVCC机制。

串行化，每次事务都需要依次执行，相当于是单线程，所以单线程根本不需要MVCC来支持，每次读都读的最新的数据。